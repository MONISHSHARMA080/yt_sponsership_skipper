<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: service-worker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: service-worker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// @ts-check

import {
    getDefaultValueOfToSkipTheSponsorAndShowTheModal,
    getKeyFromStorageOrBackend,
    getValueFromTheStorage,
    getWhereToSkipInYtVideo,
saveValueToTheStorage
} from './helper.js';
import { config } from './config.js';


console.log("hi from the service worker and will run say hi() now");
/**
 * Configuration object for authentication
 * @typedef {Object} Config
 * @property {string} BACKEND_URL - Backend service URL
 */
// const config = {
//     BACKEND_URL: "http://localhost:8080",
// };

// Initialize the config
/**
 * @typedef {Object} GetKeyMessage
 * @property {'getKeyFromStorageOrBackend'} type - Message type identifier
 */

/**
 * Message handler for Chrome extension background script
 * @param {GetKeyMessage} request - The message request object
 * @param {chrome.runtime.MessageSender} sender - Message sender information
 * @param {(response?: any) => void} sendResponse - Callback to send response
 * @returns {boolean} - Return true to indicate async response
 */
chrome.runtime.onMessage.addListener((
/**
 * Message handler for Chrome extension background script
 * @type {GetKeyMessage} request - The message request object
 * @param {chrome.runtime.MessageSender} sender - Message sender information
 * @param {(response?: any) => void} sendResponse - Callback to send response
 * @returns {boolean} - Return true to indicate async response
 */
    // @ts-ignore
    request, sender, sendResponse) => {

    if (request.type === "getKeyFromStorageOrBackend") {
    console.log("Received message in background script:", request);
        // Execute the key fetch function and handle the response
        getKeyFromStorageOrBackend(config)
            .then(([key, error]) => {
                console.log("Key fetch completed", { key: key?.substring(0, 10), error });
                sendResponse([key, error]);
            })
            .catch(error => {
                console.error("Error in background script:", error);
                sendResponse(["", error]);
            });

        // Return true to indicate we will send response asynchronously
        return true;
    }
});




/**
 * @typedef {Object} GetKeyMessage2
 * @property {'getKeyFromStorage'} type - Message type identifier
 */

/**
 * Message handler for Chrome extension background script
 * @param {GetKeyMessage} request - The message request object
 * @param {chrome.runtime.MessageSender} sender - Message sender information
 * @param {(response?: any) => void} sendResponse - Callback to send response
 * @returns {boolean} - Return true to indicate async response
 */
chrome.runtime.onMessage.addListener((
/**
 * Message handler for Chrome extension background script
 * @type {GetKeyMessage2} request - The message request object,
 * @typedef {chrome.runtime.MessageSender} sender - Message sender information
 * @typedef {(response?: any) => void} sendResponse - Callback to send response
 * @returns {boolean} - Return true to indicate async response
 */
    // @ts-ignore
    request, sender, sendResponse) => {

    if (request.type === "getKeyFromStorage") {
    console.log("Received message in background script:", request);
        // Execute the key fetch function and handle the response
        getValueFromTheStorage("key",()=>{})
            .then(([key, error]) => {
                console.log("Key fetch completed for the event ->", { key: key?.substring(0, 10), error });
                sendResponse([key, error]);
            })
            .catch(error => {
                console.error("Error in background script:", error);
                sendResponse(["", error]);
            });

        // Return true to indicate we will send response asynchronously
        return true;
    }
});



// getValueFromTheStorage("key",()=>{})



/**
 * @typedef {Object} ResponseObject
 * @property {number[]} [skipPoints] - Array of timestamps where to skip
 * @property {string} [error] - Error message if something went wrong
 */

/**
 * @typedef {Object} MessageRequest
 * @property {string} type - The type of message being sent
 * @property {string} encKey - The encryption key
 * @property {string} videoID - The ID of the YouTube video
 */

/**
 * @typedef {function([ResponseObject|null, Error|null]): void} sendResponse
 */

/**
 * @callback MessageCallback
 * @param {MessageRequest} request - The message request object
 * @param {chrome.runtime.MessageSender} sender - The message sender
 * @param {function([ResponseObject|null, Error|null]): void} sendResponse - Callback to send response
 * @returns {boolean} - Return true to indicate async response
 */

/**
 * Handles incoming messages in the Chrome extension background script
 * @type {MessageCallback}
 */

chrome.runtime.onMessage.addListener((
    /**@type {MessageRequest} request */ 
    request, 
        /** @type {chrome.runtime.MessageSender} sender */
    sender,
    /**@type {sendResponse} sendResponse*/
    sendResponse) => {

    if (request.type === "getWhereToSkipInYtVideo") {
        // Execute the key fetch function and handle the response
    console.log("Received message in background script:", request);
        getWhereToSkipInYtVideo(request.encKey, request.videoID)
            .then(([responseObject, error]) => {
                console.log("Key fetch completed", { key: responseObject, error });
                sendResponse([responseObject, error]);
            })
            .catch(error => {
                console.error("Error in background script:", error);
                sendResponse([null, error]);
            });

        // Return true to indicate we will send response asynchronously
        return true;
    }
});
/**
 * @typedef {Object} MessageRequest2
 * @property {string} type - The type of message being sent
 *
 */
chrome.runtime.onMessage.addListener((
    /** @type {{ type: string; }} */ request, /** @type {any} */ sender, /** @type {( response:[boolean, Error|null] ) => void } */ sendResponse) => {
    if (request.type === "alwaysSkipTheSponsorAndDoNotShowTheModal") {
        console.log(`got the request in the  alwaysSkipTheSponsorAndDoNotShowTheModal`, request);
        
        getDefaultValueOfToSkipTheSponsorAndShowTheModal().then(([value, error] )=>{
        console.log("Error in background script while getting the default value of to skip modal or not:->", error,"  and the value is -->",value);
        if (error !== null &amp;&amp; error instanceof Error) {
        return sendResponse([Boolean(value), error])
        }
        return sendResponse([Boolean(value), null])
       })
    return true;
    }
    return false;

})

/**
 * @typedef {Object} saveValueInStorage
 * @property {'saveValueInStorage'} type - The type identifier for saving value to storage
 * @property {string} key - The storage key to save the value under
 * @property {any} value - The value to be saved in storage
 * @export
 */

/**
 * Example usage in the message listener:
 */
chrome.runtime.onMessage.addListener((
    /** @type { saveValueInStorage} */ request,
    /** @type {any} */ sender,
    /** @type {(response: Error|null) => void} */ sendResponse
) => {
     if (request.type === "saveValueInStorage") {
        try {
        const error = saveValueToTheStorage(request.key, request.value);
        console.log("error in storing the value in the db is -->", error, "\n and the key ->", request.key, " and the value was ->",request.value);
        return sendResponse(error);
        } catch (error) {
            console.log("error in the try catch -->",error);
            return error   
        }
    }
});

/**
 * @typedef {Object} InstallDetails
 * @property {'install' | 'update' | 'chrome_update' | 'shared_module_update'} reason - The reason for the installation event
 * @property {string} [previousVersion] - Previous version of the extension, if this is an update
 * @property {string} [id] - ID of the shared module that was updated
 */
/**
 * Handles the extension's installation or update events.
 * Initializes storage with default values and shows welcome page on first install.
 * @type {InstallDetails} detail - Details about the installation event
 */

chrome.runtime.onInstalled.addListener((
    /** @type {InstallDetails} detail - Details about the installation event */
    detail)=>{
    if (detail.reason === 'install') {
        getKeyFromStorageOrBackend(config)
            .then(([key, error]) => {
                console.log("Key fetch completed on the first run ", { key: key?.substring(0, 10), error });
            })
            .catch(error => {
                console.error("Error in background script while getting the key on first run:", error);
            });

    }
})


/**
 * @typedef {Object} MessageRequest3
 * @property {string} action - The action to perform (e.g., 'getKey')
 */

/**
 * @typedef {Object} MessageResponse
 * @property {string} data - The sensitive key data
 */

/**
 * @typedef {Object} StorageData
 * @property {string} key - The sensitive key stored in extension storage
 */

/**
 * Handles external messages from whitelisted domains
 * @param {MessageRequest3} request - The request message from the website
 * @param {chrome.runtime.MessageSender} sender - Information about the message sender
 * @param {function(MessageResponse?): void} sendResponse - Callback to send response
 * @returns {boolean} - Must return true if response is async
 */
chrome.runtime.onMessageExternal.addListener(
  function(
    /**@type {MessageRequest3} */ request,
    /**@type {chrome.runtime.MessageSender} */ sender,
    /**@type  {function(MessageResponse?): void}  */ sendResponse) {
    // Validate sender origin
    if (sender.origin !== config.websiteURL) {
      console.error(`Unauthorized access attempt from ${sender.origin}`);
      sendResponse(null);
      return false;
    }

    // Validate request action
    if (request.action !== "getKey") {
      console.error(`Invalid action requested: ${request.action}`);
      sendResponse(null);
      return false;
    }

    /**
     * Retrieve key from storage and send response
     * @param {StorageData} result - The data retrieved from storage
     */
    function handleStorageData(result) {
      if (chrome.runtime.lastError) {
        console.error('Storage error:', chrome.runtime.lastError);
        sendResponse(null);
        return;
      }

      sendResponse({ data: result.key });
    }

    // Get data from storage
    chrome.storage.local.get(['key'], handleStorageData);
    return true; // Required for async response
  }
);

/**
 * @typedef {Object} RequestObjForChangingKeyOnPayment
 * @property {'paymentReceivedChangeTheKey'} type - The type of the request
 * @property {string} key - The new key to be stored
 */

/**
 * @typedef {Object} ChangeKeyResponse
 * @property {boolean} success - Indicates whether the key was successfully changed
 */

/**
 * @typedef {Object} KeyUpdateStatusMessage
 * @property {'keyUpdateStatus'} type - The type of the status update message
 * @property {boolean} success - Whether the key update was successful
 */



chrome.runtime.onMessage.addListener(
    /**
 * Message listener for handling key change requests from content script
 * @param {RequestObjForChangingKeyOnPayment} request - The request object from content script
 * @param {chrome.runtime.MessageSender} sender - Information about the sender
 * @param {function(ChangeKeyResponse): void} sendResponse - Function to call with the response
 * @returns {boolean} - Return true to indicate async response
 */
    (  request, sender, sendResponse) => { 
        if (request.type === "paymentReceivedChangeTheKey") {
            // Save the new key to storage
            console.log("in the paymentReceivedChangeTheKey", request);

        }
    }
);

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Mar 02 2025 13:58:48 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
