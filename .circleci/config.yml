# CircleCI 2.1 Configuration
version: 2.1

# Define jobs
jobs:
  build-and-test:
    # We need a machine executor because we are running docker compose,
    # which involves orchestrating containers directly on the host or a
    # dedicated Docker engine. Using a docker primary executor would run
    # commands *inside* a container, making it tricky to run docker compose
    # against the host or a remote daemon easily without extra steps like setup_remote_docker.
    machine:
      image: ubuntu-2204:2024.04.1 # Or a similar recent Ubuntu image that has Docker installed

    steps:
      # Checkout the code
      - checkout

      # Create environment files from CircleCI environment variables (secrets)
      # These secrets must be configured in your CircleCI project settings
      # or within a context used by this job/workflow.
      - run:
          name: Create root .env file
          # We echo the environment variable directly into the file.
          # Ensure ENV_FILE is set as a secret in CircleCI.
          command: |
            echo "$ENV_FILE" > .env

      - run:
          name: Create website .env file
          # Ensure WEBSITE_ENV_FILE is set as a secret in CircleCI.
          # Assumes the website/ directory exists from checkout.
          command:  |
          echo "$WEBSITE_ENV_FILE" > website/.env
          ls
          cat .env
          echo "----printed env file  in the root dir , not in the website---"
          cat website/.env

      # Build and run tests with Docker Compose
      # --build ensures the image is built using the .env files we just created
      # --exit-code-from ci makes the step's exit code the same as the 'ci' service container's exit code
      - run:
          name: Run tests using Docker Compose
          command: docker compose up --build --abort-on-container-exit ci

      # Extract logs from Docker container before it stops (if needed)
      # This assumes your logs are output to /app/tests/server.log inside the container
      # based on your Dockerfile's CMD.
      - run:
          name: Extract logs from container
          command: |
            mkdir -p ./logs
            # Find the container ID for the 'ci' service and copy the log file
            # We use 'docker compose ps -q ci' to get the container ID quietly
            docker cp $(docker compose ps -q ci):/app/tests/server.log ./logs/server.log || echo "Could not copy server.log from container"
          when: always # Run this step even if the previous step fails

      # Print server.log if available
      - run:
          name: Print server log
          command: |
            echo "=== Server Log Output ==="
            cat ./logs/server.log || echo "No server.log file found."
          when: always # Run this step even if tests failed

      # Note: The auto-merge step from your GitHub Actions is not included here
      # as it's separate from the build/test execution within Docker.
      # Implementing auto-merge would require additional steps involving git
      # configuration and potentially SSH keys or a deploy key for push access,
      # which is a separate configuration topic.


# Define workflows
workflows:
  # Workflow name (can be anything descriptive)
  build-test-docker-workflow:
    # Define the jobs to run in this workflow
    jobs:
      # List the job(s) included in this workflow
      - build-and-test: # <-- Job name listed here
          # Apply filters to this specific job within the workflow
          filters:
            branches:
              ignore: # <-- Ignore pushes to the 'main' branch
                - main
